字符串是以ASCII字符或Unicode字节排列并且以NUL(即'\0')结尾 表示的字符序列。

## 内存分区模型

C++程序在运行时，将内存分为四个区域，不同的区域赋予不同的生命周期，以提供强大的灵活编程。
**代码区**：存储程序的二进制代码，通常是只读的，以防止程序意外修改自身的指令，且是共享的，以减少内存消耗。
**全局区**：存储全局变量、静态变量和常量，包括已初始化和未初始化的数据。该区域中的数据在程序运行期间一直存在，结束后由操作系统回收。
**堆区**：由程序员手动分配和释放内存。可以使用 new 运算符在堆区分配内存，使用 delete 运算符释放内存。堆区中的数据生命周期由程序员控制，若程序员不释放，则在程序结束时由操作系统回收。
**栈区**：由编译器自动分配和释放内存，用于存储局部变量和函数调用时的参数，栈区中的数据生命周期与函数调用相关。

## 字符串机制

以字符串字面量定义字符串时会将其分配到字面量池中,这个内存区域通常保存组成字符串的字符序列,该内存区域通常被认为是全局的。字符字面量在池中通常只有一份副本并且是只读的,这样可以减少程序的内存占用率。

可以得出以下特性:

- 将同样一份字符串字面量的地址直接赋给不同的字符指针,不会产生额外字符串的副本,这些字符指针指向同一份字符串字面量。
- 以字符数组初始化字符串字面量会在对应的函数栈内生成另外一份的字面量副本。
- 如果在全局区以字符数组初始化字符串字面量,会在全局数据区生成另外一份的字面量副本。

## `std::string` 对象的分配

**栈上分配**：
当你在函数内部声明一个 `std::string` 对象时，它通常会被分配在栈上。例如：

```c++
void someFunction() {
    std::string str = "Hello, World!";  // str 分配在栈上
    // 使用 str
}  // str 在函数结束时自动销毁
```

在这种情况下，`std::string` 对象 `str` 本身是分配在栈上的，但是它内部管理的字符数据（即实际的字符串内容）是动态分配在堆上的。`std::string` 类会负责管理这些堆上分配的内存，确保在对象生命周期结束时正确释放这些内存。

**堆上分配**：
如果你使用 `new` 运算符来创建 `std::string` 对象，它会被分配在堆上。例如：

```c++
void someFunction() {
    std::string* strPtr = new std::string("Hello, World!");  // strPtr 指向堆上的 std::string 对象
    // 使用 *strPtr
    delete strPtr;  // 需要手动释放堆上的内存
}
```

在这种情况下，`std::string` 对象本身是分配在堆上的，但是它内部管理的字符数据（即实际的字符串内容）也是动态分配在堆上的。你需要手动调用 `delete` 来释放堆上的 `std::string` 对象，以避免内存泄漏。

**静态存储期**：
如果你在全局或命名空间作用域声明一个 `std::string` 对象，它具有静态存储期，会被分配在静态存储区。例如：

```c++
std::string globalStr = "Hello, World!";  // globalStr 具有静态存储期

void someFunction() {
    // 使用 globalStr
}
```

在这种情况下，`std::string` 对象 `globalStr` 本身是分配在静态存储区的，但是它内部管理的字符数据（即实际的字符串内容）是动态分配在堆上的。`std::string` 类会负责管理这些堆上分配的内存，确保在程序结束时正确释放这些内存。

**总结**：

- `std::string` 对象本身可以分配在栈上、堆上或具有静态存储期。
- `std::string` 对象内部管理的字符数据通常是动态分配在堆上的。但是有些更多细节。例如SSO的处理。

`std::string` 的 SSO（Small String Optimization，小字符串优化）是一种优化技术，用于减少小字符串的动态内存分配。在许多 `std::string` 的实现中，当字符串的长度小于某个阈值时，字符串数据会直接存储在 `std::string` 对象的内部缓冲区中，而不是动态分配的堆内存中。这样可以避免小字符串的内存分配和释放开销，提高性能。

基本原理是：**当分配大小小于16个字节时候，从栈上进行分配，而如果大于等于16个字节，则在堆上进行内存分配**。PS：需要注意的是，此优化自GCC5.1生效，也就是说对于GCC版本小于5的，无论长度为多少，都从堆上进行分配。

```c++
#include <cstdlib>
#include <iostream>
#include <string>
 
void* operator new(std::size_t n) {
  std::cout << "[Allocating " << n << " bytes]";
  return malloc(n);
}
void operator delete(void* p) throw() {
  free(p);
}
 
int main() {
  for (size_t i = 0; i < 24; ++i) {
    std::cout << i << ": " << std::string(i, '=') << std::endl;
  }
  return 0;
}
```

在上述代码中，我们重载operator new, 以替换string中new实现，这样做的好处是可以通过输出来发现是否调用了new进行动态分配。

## 为什么c++ std::string对象不能直接用memcopy函数拷贝？

尽管 `std::string` 实现了 SSO（Small String Optimization，小字符串优化），但这并不意味着可以直接使用 `memcpy` 或 `memmove` 来复制 `std::string` 对象。原因如下：

1. **内部状态的丢失**：`std::string` 对象内部维护了字符串的长度和容量等信息。直接使用 `memcpy` 复制字符串对象时，这些内部状态信息可能会被破坏或丢失，导致字符串对象处于无效状态。
2. **内存管理问题**：`std::string` 对象可能包含指向动态分配内存的指针。直接使用 `memcpy` 复制这些指针时，会导致两个 `std::string` 对象指向同一块内存，这可能会导致内存泄漏或双重释放等问题。
3. **线程安全性**：`std::string` 对象的内部状态可能在多线程环境中被修改。直接使用 `memcpy` 复制字符串对象时，可能会导致线程安全问题。
4. **异常安全性**：`std::string` 的复制构造函数和赋值操作符通常会提供异常安全性保证，即在复制过程中如果发生异常，原始对象的状态不会被破坏。而 `memcpy` 不具备这种保证，可能会导致原始对象和目标对象都处于无效状态。
5. **内部布局的不确定性**：`std::string` 对象的内部布局是未定义的，不同的编译器和标准库实现可能会有不同的内部布局。直接使用 `memcpy` 复制字符串对象时，可能会因为内部布局的不同而导致未定义行为。

即使在使用 SSO 的情况下，`std::string` 对象的内部结构仍然是一个复杂的对象，包含多个成员变量和内部状态。直接使用 `memcpy` 复制这些成员变量和内部状态可能会导致未定义行为。

为了避免这些问题，应该使用 `std::string` 提供的复制构造函数或赋值操作符来进行字符串的复制。